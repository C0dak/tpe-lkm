On some KVM virtual machines, insertion of tpe causes the VM to crash. This
patch appears to fix the issue - but causes xen kernels to crash when inserted.
Quite the tradeoff, eh?

Since this patch was kind of rushed, I didn't want to put it straight in. Also,
all my own testing systems are either bare-metal or Xen, so I haven't had much
by the way of resources to test it beyond the initial "okay we're good now!".
At some point in the future, I'll get this in so the module works right with
bare-metal, KVM, and xen kernel environments without having to patch anything.

This patch is a temporary measure until a more permanent solution is put in.

Feedback is appriciated.

diff --git a/hijacks.c b/hijacks.c
index e565be8..fc7f348 100644
--- a/hijacks.c
+++ b/hijacks.c
@@ -71,46 +71,51 @@ void copy_and_fixup_insn(struct insn *src_insn, void *dest,
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
 
-#include <asm/cacheflush.h>
-
-// TODO: this implementation just ignores the flag, not currently sure how to check
-//	   if the page is already set to read/write
-
-void set_addr_rw(unsigned long addr, bool *flag) {
-
-	struct page *pg;
-
-	pgprot_t prot;
-	pg = virt_to_page(addr);
-	prot.pgprot = VM_READ | VM_WRITE;
-	change_page_attr(pg, 1, prot);
+// copied from centos5 arch/x86_64/mm/pageattr.c
 
+static inline pte_t *tpe_lookup_address(unsigned long address, unsigned int *level)
+{
+	pgd_t *pgd = pgd_offset_k(address);
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
+	if (pgd_none(*pgd))
+		return NULL;
+	pud = pud_offset(pgd, address);
+	if (!pud_present(*pud))
+		return NULL;
+	pmd = pmd_offset(pud, address);
+	if (!pmd_present(*pmd))
+		return NULL;
+	if (pmd_large(*pmd))
+		return (pte_t *)pmd;
+	pte = pte_offset_kernel(pmd, address);
+	if (pte && !pte_present(*pte))
+		pte = NULL;
+	return pte;
 }
 
-void set_addr_ro(unsigned long addr, bool flag) {
-
-	struct page *pg;
-
-	pgprot_t prot;
-	pg = virt_to_page(addr);
-	prot.pgprot = VM_READ;
-	change_page_attr(pg, 1, prot);
+#else
 
-}
+#define tpe_lookup_address(address, level) lookup_address(address, level);
 
-#else
+#endif
 
 void set_addr_rw(unsigned long addr, bool *flag) {
 
 	unsigned int level;
 	pte_t *pte;
 
+#if defined(CONFIG_XEN) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+	return;
+#else
 	*flag = true;
 
-	pte = lookup_address(addr, &level);
+	pte = tpe_lookup_address(addr, &level);
 
-	if (pte->pte & _PAGE_RW) *flag = false;
-	else pte->pte |= _PAGE_RW;
+	if (pte_val(*pte) & _PAGE_RW) *flag = false;
+	else pte_val(*pte) |= _PAGE_RW;
+#endif
 
 }
 
@@ -119,17 +124,19 @@ void set_addr_ro(unsigned long addr, bool flag) {
 	unsigned int level;
 	pte_t *pte;
 
+#if defined(CONFIG_XEN) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+	return;
+#else
 	// only set back to readonly if it was readonly before
 	if (flag) {
-		pte = lookup_address(addr, &level);
+		pte = tpe_lookup_address(addr, &level);
 
-		pte->pte = pte->pte &~_PAGE_RW;
+		pte_val(*pte) = pte_val(*pte) &~_PAGE_RW;
 	}
+#endif
 
 }
 
-#endif
-
 int symbol_hijack(struct kernsym *sym, const char *symbol_name, unsigned long *code) {
 
 	int ret;
